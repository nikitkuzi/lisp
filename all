;Определите функцию, возвращающую последний элемент списка.
(defun returnlast (list1)
	(print (last list1))
)
(returnlast '(1 2 3)) ; => (3)
(returnlast '(1 2 (3))) ; => ((3))
(returnlast '(1 2 ())) ; => (NIL)
(print '2_end)

;6. Определите функци, переводщу список чисел в список соответствующихим названий
; Не совсем понял, что необходимо делать в этом задании.
(defun fromNumsToNames (list1)
	(cond
 		(
 			(null list1) nil
 		)
 		(
 			(cons
 				(write-to-string (car list1))
 				(fromNumsToNames (cdr list1))
 			)
 		)
 	)
)
(print(fromNumsToNames '(1 2 3))) ; => ("1" "2" "3")
(print '6_end)

; Определите функцию, осуществляющую перестановку двух элементов списка с заданными номерами
(setf lstt '(1 2 3 4))
(defun swap (list1 pos1 pos2)
    (rotatef 
        (nth pos1 list1) 
        (nth pos2 list1)
    )
)
(swap lstt 0 3)
(print lstt)
(print '14_end)

;Определите функцию (ЛУКОВИЦА n), строящую N-уровневый вложенный список, элементом которого на самом глубоком уровне является N.
(defun Луковица (n)
	(do ((a n)); create variable a with value of n
		((= n 1) (list a)); break statement
		(setq a (list a))
		(setq n (- n 1))))
(print(Луковица 2))
(print '19_end)

; Определите функцию, удаляющую из списка первое вхождение данного элемента на верхнем уровне.
(defun RemoveFirst(lst elem)
	(setq a '()); temp list
	(setq flag '0); checker done or not
	(dolist (element lst); loop through list
		(cond
			((= flag 1); if first element has already been removed
				(setq a (append a (list element))); append new list
			)
			((equalp element elem) 
				(setq flag '1); if elements are equal change checker and do nothing
			)
			(T
				(setq a (append a (list element))); append new list
			)
		)
	)
	a; return value
)
(print(RemoveFirst '(1 2 3 4 5 5) 5))
(print '21_end)

; Определите функции, преобразующие список (a b с) к виду (а (b (с))) и наоборот.
(defun transformToOneList (lst)
	(cond
		((null lst); last element
			nil
		)
		((atom (car lst)); if there are no nested lists just add
			(cons (car lst) (transformToOneList (cdr lst)))
		)
		(T; if there are we have to remove them
			(append (transformToOneList (car lst)) (transformToOneList (cdr lst)))
		)
	)
)


(defun transformToNestedList (lst)
	(cond
		((null (cdr lst)); to prevent adding nil to the end
			lst
		)
		(T; just loop through the list adding to the end
			(list (car lst) (transformToNestedList (cdr lst)))
		)
	)
)

(print (transformToOneList '(1 2 3 ((5)) (4))))
(print (transformToNestedList '(1 2 3)))
(print '23_end)

; Определите предикат РАВЕНСТВО-МНОЖЕСТВ, проверяющий совпадение двух мно-
; жеств (независимо от порядка следования элементов). Подсказка: напишите
; функцию УДАЛИТЬ, удаляющую данный элемент из множества
(defun RemoveFirst(lst elem) ; from 21 task
	(setq a '()); temp list
	(setq flag '0); checker done or not
	(dolist (element lst); loop through list
		(cond
			((= flag 1); if first element has already been removed
				(setq a (append a (list element))); append new list
			)
			((equalp element elem) 
				(setq flag '1); if elements are equal change checker and do nothing
			)
			(T
				(setq a (append a (list element))); append new list
			)
		)
	)
	a; return value
)

(defun equalSet (lst1 lst2)
	(cond
		((null lst1)
			(cond
				((null lst2); if the first list is empty and so is the second then the are equal
					T
				)
				(T; else not
					nil
				)
			)
		)
		((null lst2); if the second one is empty then this means that the first condition was false
			nil
		)
		(T
			(setq lst2 (RemoveFirst lst2 (car lst1))); trying to remove the first element of the list 1 from the second
			(setq lst1 (RemoveFirst lst1 (car lst1))); removing the first element
			(equalSet lst1 lst2)
		)
	)
)

(print(equalSet '(1 2 3) '(1 3 2)))
(print '34_end)


; Определите функцию РАЗНОСТЬ, формирующую разность двух множеств, т.е.
; удаляющую из первого множества все общие со вторым множеством элементы.
(defun Subtraction(lst1 lst2) ; similar to task 21
	(dolist (elementInTheSecondList lst2)
		(setq a '()); temp list
		(dolist (elementInTheFirstList lst1)
			(cond
				((equalp elementInTheFirstList elementInTheSecondList) 
					; if elements are equal do nothing
				)
				(T
					(setq a (append a (list elementInTheFirstList))); append new list and continue
				)
			)
		)
		(setq lst1 a)
	)
	a; return value
)

(print(Subtraction '(1 (2) 3) '(1 (2)) ))

(print '40_end)

; Определите функцию, подсчитывающую количество всех вершин данного дерева заданной высоты.
(setq ans 0)
(defun solve (lst n)
	(setq flag 0); temporary flag for nodes
	(dolist (elem lst)
		(cond
			((< n 1) ; depth
				(cond
					((= flag 1)); if node has already been found do nothing
					(T
						(setq ans (+ ans 1))
					)
				)
			)
			((atom elem) ; if current element is the node
				(setq n (- n 1)); then decrease the depth
				(setq flag 1); mark found node
				(setq ans (+ ans 1))
				
			)
			((= flag 1); look deeper 
				(solve elem n)
			)
		)
	)
)
(defun countLeafs(lst n)
	(solve lst n)
	ans
)

(setq tree '(1 
				(2 
					(3) (4) (5) (6)
				) 
				(7 
					(8) (9 10) (11
									(12)
								)
				)
			)
)
(print (countLeafs tree 3)); tree, depth
(print '43_end)

;Предположим, что отец и мать некоторого лица, хранятся как значения 
;соответствующих свойств у символа, обозначазщего это лицо. Напишите функцию 
;РОДИТЕЛИ x), которая возвращает в качестве значения родителей, и предикат 
;(СЕСТРЫ-БРАТЬЯ x1 x2), который истинен в случае, если x1 и x2  сестры или 
;братья, родные или с одним общим родителем.
(defun setParent(child father mother)
	(setf (get child 'father) father)
	(setf (get child 'mother) mother)
)
(defun getParent (child)
	(list
		(get child 'father)
		(get child  'mother)
	)
)
(defun siblings(child1 child2)
	(cond
		((equalp (getParent child1) (getParent child2))
			T
		)
		((equalp (car (getParent child1)) (car (getParent child2)))
			T
		)
		((equalp (cdr (getParent child1)) (cdr (getParent child2)))
			T
		)
		(T
			nil
		)
	)
)
(setParent 'x 'z 'y)
(setParent 'xx 'm 'n)
(print (getParent 'x))
(print (siblings 'x 'xx))
(print '46_end)

; Определите FUNCALL через функционал APPLY.
(defun func (function &rest arguments)
	(apply function arguments)
)
(print (func '* 1 2 3 4 5))
(print '1_high_end)

;Определите функционал (APL-APPLY f x), который применяет каждую функцию fi списка
;(f1 f2 ... fn)
;к соответствующему элементу списка
;x = (x1 x2 ... xn)
;и возвращает список, сформированный из результатов.

(defun power(n)
	(* n n)
)
(defun increase(n)
	(+ n 1)
)
(defun duplicate(n)
	(list n n)
)
(defun apl-apply(f x)
	(cond
		((not (null x))
			(cons 
				(funcall (car f) (car x))
				(apl-apply (cdr f) (cdr x))
			)
		)
	)
)
(print (apl-apply '(power increase duplicate) '(10 10 10)))
(print '3_high_end)

; Определите функциональный предикат (НЕКОТОРЫй пред список), 
;который истинен, когда, являющейся функциональным аргументом 
;предикат пред истинен хотя бы для одного элемента списка список.
(defun negative(elem)
	(if (numberp elem)
		(cond
			((< elem 0)	T)
			(T nil)
		)
	)
)
(defun func(fn lst)
	(mapcan fn lst)
)
(print(func 'negative '(1 2 -3)))
(print '5_high_end)

;Определите фильтр (УДАЛИТЬ-ЕСЛИ-НЕ пред список), удаляющий из списка список
;все элементы, которые не обладают свойством, наличие которого проверяет
;предикат пред.

(defun negative(elem)
	(if (numberp elem)
		(cond
			((< elem 0)	T)
			(T nil)
		)
	)
)
(defun deleteIfNot(fn lst)
	(print (mapcan #'(lambda (x) (if (funcall fn x) (list x) nil)) lst))
)
(deleteIfNot 'negative '(1 -2 -3))
(print '7_high_end)

;Напишите генератор порождения чисел Фибоначчи: 0, 1, 1, 2, 3, 5,
(defun fib()
	(let 
		((a 0) (b 1))
 		(lambda () 
 			(setq a (+ a b))
 			(setq b (- a b))
		)
 	) 
)
(setq nextFib (fib))
(setq nextFib1 (fib))
(print (funcall nextFib))
(print (funcall nextFib))
(print (funcall nextFib))
(print (funcall nextFib))
(print (funcall nextFib))
(print (funcall nextFib))
(print (funcall nextFib))
(print (funcall nextFib))
(print (funcall nextFib))
(print (funcall nextFib1))
(print (funcall nextFi1))
(print (funcall nextFi1))
(print '9_high_end)

; Определите фукнционал МНОГОФУН, который использует функции, являющиеся
; аргументами, по следующей схеме:
; (МНОГОФУН ’(f g ... h) x) ⇔ (LIST (f x) (g x) ... (h x)).
(defun power(n)
	(* n n)
)
(defun increase(n)
	(+ n 1)
)
(defun duplicate(n)
	(list n n)
)
(defun multifun (fn n)
	(mapcar #'(lambda (x) (list x (funcall x n))) fn)
)
(print (multifun '(power increase duplicate power) 10))
(print '11_high_end)
